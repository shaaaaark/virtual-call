---
description:
globs:
alwaysApply: false
---
# 模拟来电APP架构设计

## 系统架构

模拟来电APP采用分层架构设计，清晰分离关注点，提高代码可维护性和扩展性：

```
┌─────────────────────────────────────────────────────────┐
│                      应用层                              │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐     │
│  │ 引导模块 │  │ 一键来电 │  │自定义来电│  │定时任务来电│     │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘     │
├─────────────────────────────────────────────────────────┤
│                      业务逻辑层                          │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐     │
│  │Redux状态│  │Hook逻辑 │  │ API服务 │  │ 工具函数 │     │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘     │
├─────────────────────────────────────────────────────────┤
│                      数据访问层                          │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐     │
│  │本地存储 │  │通知服务 │  │设备信息 │  │资源管理 │     │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘     │
├─────────────────────────────────────────────────────────┤
│                      原生功能层                          │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐     │
│  │铃声模块 │  │震动模块 │  │通知模块 │  │权限模块 │     │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘     │
└─────────────────────────────────────────────────────────┘
```

## 核心设计模式

项目使用以下设计模式:

1. **容器/展示组件模式**: 分离业务逻辑和UI渲染
2. **Hook模式**: 使用自定义Hook封装和复用业务逻辑
3. **服务模式**: 封装特定功能域的复杂逻辑到服务类
4. **策略模式**: 用于处理不同手机品牌的来电界面模板
5. **观察者模式**: 使用Redux实现状态变化的观察和响应

## 数据流设计

### 一键来电数据流
```
用户触发 → Action分发 → Reducer更新状态 → 调用原生模块(铃声/震动) → 渲染来电界面
```

### 自定义来电数据流
```
用户设置 → 表单验证 → 存储设置 → (选择立即启动) → 调用原生模块 → 渲染来电界面
```

### 定时任务数据流
```
用户创建任务 → 存储任务信息 → 注册本地通知 → 时间到达 → 触发通知 → 启动应用 → 渲染来电界面
```

## 状态管理

项目使用Redux Toolkit管理全局状态:

```typescript
// Redux切片示例
const callUISlice = createSlice({
  name: 'callUI',
  initialState: {
    isCallActive: false,
    currentCallInfo: null,
    currentTemplate: 'iphone'
  },
  reducers: {
    setCallActive: (state, action) => {
      state.isCallActive = action.payload;
    },
    setCurrentCallInfo: (state, action) => {
      state.currentCallInfo = action.payload;
    },
    setCurrentTemplate: (state, action) => {
      state.currentTemplate = action.payload;
    }
  }
});
```
